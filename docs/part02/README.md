<h1 align="center">📔 Part II : Creating High-Quality Code 学习笔记</h1>

- [Chapter 05 软件构建中的设计](#chapter-05-软件构建中的设计)
  - [1. 设计中的挑战](#1-设计中的挑战)
  - [2. 关键的设计概念](#2-关键的设计概念)
    - [2.1 软件的首要技术任务：管理复杂度](#21-软件的首要技术任务管理复杂度)
    - [2.2 理想的设计特征](#22-理想的设计特征)
    - [2.3 设计的层次](#23-设计的层次)
  - [3. 设计构造块：启发式方法](#3-设计构造块启发式方法)
    - [3.1 启发式的几个方法](#31-启发式的几个方法)
      - [3.1.1. 找出现实世界中的对象](#311-找出现实世界中的对象)
      - [3.1.2 形成一致的抽象](#312-形成一致的抽象)
      - [3.1.3 封装实现细节](#313-封装实现细节)
      - [3.1.4 当继承能简化设计时就继承](#314-当继承能简化设计时就继承)
      - [3.1.5 隐藏秘密（信息隐藏）](#315-隐藏秘密信息隐藏)
      - [3.1.6 找出容易改变的区域](#316-找出容易改变的区域)
      - [3.1.7 保持松散耦合](#317-保持松散耦合)
      - [3.1.8 常用的设计模式](#318-常用的设计模式)
      - [3.1.9 其他的启发式方法](#319-其他的启发式方法)
    - [3.2 使用启发式方法的原则](#32-使用启发式方法的原则)
  - [4. 设计实践](#4-设计实践)
- [Chapter 06 可以工作的类](#chapter-06-可以工作的类)
  - [1. 类的基础：抽象数据类型](#1-类的基础抽象数据类型)
    - [1.1 使用ADT的好处](#11-使用adt的好处)
  - [2. 良好的类接口](#2-良好的类接口)
    - [2.1 好的抽象](#21-好的抽象)
    - [2.2 好的封装](#22-好的封装)
  - [3. 有关设计和实现的问题](#3-有关设计和实现的问题)
    - [3.1 包含（“有一个...”的关系）](#31-包含有一个的关系)
    - [3.2 继承（“是一个...”的关系）](#32-继承是一个的关系)
    - [3.3 使用继承还是包含的规则总结](#33-使用继承还是包含的规则总结)
    - [3.4 成员函数和数据成员](#34-成员函数和数据成员)
    - [3.5 构造函数](#35-构造函数)
  - [4. 创建类的原因](#4-创建类的原因)
  - [6. 应该避免的类](#6-应该避免的类)
  - [7. 与具体编程语言相关的问题](#7-与具体编程语言相关的问题)
  - [8. 超越类：包](#8-超越类包)
- [Chapter 07 高质量的子程序](#chapter-07-高质量的子程序)
  - [1. 创建子程序的正当理由](#1-创建子程序的正当理由)
  - [2. 在子程序上设计](#2-在子程序上设计)
  - [3. 好的子程序名字](#3-好的子程序名字)
  - [4. 子程序可以写多长？](#4-子程序可以写多长)
  - [5. 如何使用子程序参数？](#5-如何使用子程序参数)
  - [6. 使用函数时要特别考虑的问题](#6-使用函数时要特别考虑的问题)
  - [7. 宏子程序和内联子程序](#7-宏子程序和内联子程序)
- [Chapter 08 防范式编程](#chapter-08-防范式编程)
  - [1. 保护程序免遭无效输入数据的破坏](#1-保护程序免遭无效输入数据的破坏)
  - [2. 断言](#2-断言)
  - [3. 错误处理技术](#3-错误处理技术)
  - [4. 异常](#4-异常)
  - [5. 隔离程序以免遭由错误造成的损害](#5-隔离程序以免遭由错误造成的损害)
  - [6. 辅助调试代码](#6-辅助调试代码)
  - [7. 确定在产品代码中该保留多少防范式代码](#7-确定在产品代码中该保留多少防范式代码)
  - [8. 防范式编程时保持防范](#8-防范式编程时保持防范)
- [Chapter 09 伪代码编程过程](#chapter-09-伪代码编程过程)
  - [1. 创建类和子程序的步骤概述](#1-创建类和子程序的步骤概述)
  - [2. 伪代码](#2-伪代码)
  - [3. 通过伪代码编程过程创建子程序](#3-通过伪代码编程过程创建子程序)
  - [4. 伪代码编程过程之外的其它方案](#4-伪代码编程过程之外的其它方案)


# Chapter 05 软件构建中的设计
一个好的类或者子程序的设计在很大程度上是由系统的架构所决定的。

## 1. 设计中的挑战

设计是把需求分析和编码调试连接在一起的活动。

- 设计是一个险恶的问题
  - 险恶问题的定义：只有通过解决或部分解决才能被明确的问题。

- 设计是个了无章法的过程（即使它能得出清爽的成果）
  - 软件设计的成果是组织良好、干净利落的。
  - 了无章法的原因
    - 在设计过程中，会采取了多种错误的步骤，多次误入歧途。
    - 难判断是否足够好

- 设计就是确定取舍和调整顺序的过程
  - 完美的程序并不存在。
  - 设计中的一个关键内容：去衡量彼此冲突的各项设计特性，并尽力在其中寻求平衡。

- 设计受到诸多限制
  - 设计的要点：
    - 一部分是在创造可能发生的事情
    - 另一部分是在限制可能发生的事情。

- 设计是不确定的

- 设计是一个启发式过程
  - 因不确定性，故设计技术也就具有探索性。
  - “经验法则” 或者 “试试没准能行的方法”，而不是保证能产生预期结果的可重复的过程。

- 设计是自然而然的过程
  - 设计不是在谁的头脑中跳出来的。是在不断地设计评估、非正式讨论、写试验代码以及修改试验代码中演化和完善的。


## 2. 关键的设计概念
好的设计源于对一小批关键设计概念的理解。

### 2.1 软件的首要技术任务：管理复杂度

- 偶然的难题和本质的难题
  - 本质的属性：一件事物必须具备、如果不具备就不再是该事物的属性。
  - 偶然的属性：一件事物碰巧具有的属性，有没有这些属性都并不影响这件事物本身。

- 管理复杂度的重要性
  - 当项目确由技术因素导致失败时，其原因通常就是失控的复杂度。
  - 尽量减少在任一实践所要考虑的程序量。
  - 在软件架构的层次上，可以通过把整个系统分解为多个子系统来降低问题的复杂度。
  - 保持子程序的短小精悍能帮助你减少思考的负担。
  - 要写出自己容易理解，也让别人容易看懂，而且很少有错误的程序代码。


- 如何应对复杂度
  - 高代价、低效率的设计来源于三种根源：
    - 用复杂的方法解决简单的问题。
    - 用简单但错误的方法解决复杂的问题。
    - 用不恰当的复杂方法解决复杂的问题。

  - 管理复杂度的两种方法：
    - 把任何人在同一时间需要处理的本质（essential）复杂度的量减到最少。
    - 不要让偶然性（accidental）的复杂度无谓地快速增长。

### 2.2 理想的设计特征

- 最小的复杂度（Minimal complexity）
  - 做出简单易于理解的设计，而不是做出 “聪明” 的设计。

- 易于维护（Ease of maintenance）
  - 在设计时要为维护工作考虑。

- 松散耦合（loose coupling）
  - 设计时让程序的各个组成部分之间关联最小。

- 可扩展性（extensibility）
  - 可增强系统的功能而无须破坏其底层结构。

- 可重用性（reusability）
  - 系统的组成部分能在其它系统中重复使用。

- 高扇入（high fan-in）
  - 让大量的类使用某个给定的类。

- 低扇出（low fan-out）
  - 让一个类里少量或适中地使用其他的类。

- 可移植性（portability）
  - 方便移植到其它平台或者环境中。

- 精简性（leanness）
  - 设计出的系统没有多余的部分。
  - 要考虑到向后兼容性。

- 层次性（stratification）
  - 尽量保持系统各个分解层的层次性。
  - 可以通过观察层次即可，而不是深入到其它层次。

- 标准技术（Standard techniques）
  - 尽量用标准化、常用的方法。


### 2.3 设计的层次
一个软件系统的设计层次，可以通过自顶向下的设计方法，通过宏观，从而进一步细化成多个子层次：
- 软件系统
  - 整个系统
- 分解为子系统或包
  - 该层次主要是识别出所有的主要子系统。
  - 此时主要的活动是：确定如何把程序分为主要的子系统，并定义清楚允许给子系统如何使用其他子系统。
  - 注意不同子系统之间相互通信的规则。
  - 为了让子系统之间的连接简单易懂且易于维护，要尽量简化子系统之间的交互关系。

- 分解为类
  - 该层次的设计包括识别出系统中所有的类。
  - 此时的主要设计任务：把所有的子系统进行适当的分解，并确保分解出的细节可以用单个的类来实现。
  - 对象和类的比较：
    - 对象：运行期间在程序中实际存在的具体实体。
    - 类：在程序源码中存在的静态事物。

- 分解为子程序
  - 该层的设计是把每个类细分为子程序。
  - 在做分解类时，做了一部分的子程序，此时就需要将细化出类的私用子程序。
  - 完整地3定义出类内部的子程序，有助于更好地理解类的接口。

- 子程序内部的设计
  - 为每个子程序布置详细的功能。

## 3. 设计构造块：启发式方法
软件设计是非确定性的，所以就需要灵活运用一些有效的启发式方法，便成了合理的软件设计的核心工作。
### 3.1 启发式的几个方法

#### 3.1.1. 找出现实世界中的对象
- 在确定设计方案时，首选使用的是 “常规的”面向对象设计方法。该方法的要点是辨识现实世界中的对象（object，物体）以及人造（synthetic）对象。
- 使用对象进行设计的步骤：
  - 辨识对象及其属性（方法（Method）和数据（data））。
    - 计算机程序通常是基于现实世界的实体。
    - 辨识对象的属性并不比辨识对象本身更困难。每个对象都有一些与计算机程序相关的特征。

  - 确定可以对各个对象进行的操作
    - 在每个对象之上都可以执行多种操作。

  - 确定各个对象能对其他对象进行的操作。
    - 对象之间最常见的两种关系：包含（containment）和继承（inheritance）。

  - 确定对象的那些部分对其他对象可见 --- 哪些部分可以是公用（public）的，哪些部分应该是私用（private）的。

  - 定义每个对象的公开接口（public interface）。
    - 在编程语言的层次上为每个对象定义具有正式语法的接口。
    - 对象对其他`对象暴露`的`数据`及`方法`都被称为该对象的 **`“公开接口/public interface”`**。
    - 对象通过`继承关系`向其`派生对象`暴露的部分则称为 **`“受保护的接口/protected interface”`**。

两种迭代方法：
- 在高层次的系统组织结构上进行迭代，以便于更好地组织类的结构。
- 在每一个已经定义的类上进行迭代，把每个类的设计细化。

#### 3.1.2 形成一致的抽象
- 抽象可以让你在关注某一概念的同时可以放心地忽略其中一些细节的能力（在不同的层次处理不同的细节）。
- 基类也是一种抽象，能集中精力关注一组派生类具有的共同特性，并在基类的层次上忽略各个具体派生类的细节。

- 从复杂角度来说，抽象的主要好处：使你忽略无关的细节。

#### 3.1.3 封装实现细节
- 封装填补了抽象留下的空白。
- 封装就是将复杂的东西进行隐藏。

#### 3.1.4 当继承能简化设计时就继承
- 定义对象之间的相同点和不同点的部分就叫 “继承”。

- 继承的作用：更好地辅助抽象的概念。抽象是从不同的细节层次来看对象的。

- 继承可以简化编程的工作，但是继承是一把双刃剑，使用得当，能带来极大的益。如果使用不当，则有极大的弊端。

#### 3.1.5 隐藏秘密（信息隐藏）
- 信息隐藏是结构化程序设计与面向对象设计的基础之一。结构化设计里的“黑盒子”概念就是来源于信息隐藏。
  - 面向对象设计中，引出封装和模块化的概念，并与抽象的概念密切相关。
  - 信息隐藏是软件开发中一个开拓性的概念。

- 软件开发者将设计和实现决策隐藏，使得程序的其他部分看不到。

- 信息隐藏是软件的首要技术使命中格外重要的一种启发式方法。
  - 主要强调了隐藏复杂度。

- 当信息被隐藏后，每个类（或者包和子程序）都代表了某种对其他类保密的设计或者构建决策。

- 隐藏起来的秘密可能是某个易变的区域，或者某种文件格式或者某种数据类型的实现方式。

#### 3.1.6 找出容易改变的区域
- 好的程序设计所面临的最重要挑战之一：适应变化。
  - 将不稳定的区域隔离出来，从而将变化所带来的影响限制在一个子程序类或者包的内部。

对于变动来说，可以采取的一些措施：
- 找出看起来容易变化的项目。
  - 从需求中找出潜在的可能性。

- 把容易变化的项目分离出来。
  - 找出容易变化的组件单独划分成类，或者将同时变化的组件划分到同一个类中。

- 把看起来容易变化的项目隔离开来。
  - 设计好类的接口，把变化限制在类的内部，且不会影响类的外部。
  - 类的接口应该肩负起保护类的隐私的职责。

容易发生变化的区域：
- 业务规则
- 对硬件的依赖性。
- 输入和输出。
- 困难的设计区域和构建区域。
- 状态变量。
- 数据量的限制。


#### 3.1.7 保持松散耦合
**`耦合度`**：表示类与类之间或者子程序与子程序之间关系的紧密程度。

耦合度设计的目标是创建小的、直接的、清晰的类或者子程序，使得与其他类或子程序之间关系尽可能灵活。

模块之间好的耦合关系会松散到恰好能使一个模块能够很容易被其他模块使用。

在软件中，确保模块之间的连接关系尽可能地简单。也尽量使创建的模块不依赖或者很少依赖其他模块。

- 衡量模块之间耦合度时可采用的标准
  - 规模
    - 模块之间的连接数。

  - 可见性
    - 两个模块之间的连接的显著程度。

  - 灵活性
    - 模块之间的连接是否容易改动。

- 常见的几种耦合种类
  - 简单数据参数耦合
    - 当两个模块之间泰国参数来传递数据，且所有的数据都是简单数据类型时。这种耦合关系是正常的，也可接受。

  - 简单对象耦合
    - 一个模块实例化一个对象。
  
  - 对象参数耦合
    - 参数传递的是一个对象。和简单数据类型相比，耦合关系更紧密。

  - 语义上的耦合
    - 一个模块不仅使用了另一个模块的语法元素，还使用了有关模块内部工作细节的语义知识。
    - 尽量避免这种耦合方式，因为更改被调用的模块中的代码可能会破坏掉用它的模块。破坏的方式编译器会无法检查。


#### 3.1.8 常用的设计模式
设计模式的好处：
- 设计模式通过提供现成的抽象来减少复杂度。

- 设计模式通过常见解决方案的细节予以制度化来减少出错。

- 设计模式通过提供多种设计方法而带来启发式的价值。

- 设计模式通过把设计对话提升到一个更高的层次上简化交流。

常见的设计模式：
|模式|描述|
|--|--|
|Abstract Factory（抽象工厂）|通过指定对象组的种类而非单个对象的类型来支持创建一组相关的对象|
|Adapter（适配器）|把一个类的接口转变为另一个接口|
|Bridge（桥接）|把接口和实现分开，使他们可以独立地变化。|
|Composite（组合）|创建一个包含其他同类对象的对象，使得客户代码可以与最上层对象交互而无须考虑所有的细节对象。|
|Facade（外观）|为没有提供一致接口的代码提供一个一致的接口|
|Factory Method|做特定基类的派生类的实例化时，除了在Factory Method内部之外均无须了解各派生类对象的具体类型|
|Iterator（迭代器）|提供一个服务对象来顺序地访问一组元素中的各个元素|
|ObServer（观察者）|使一组相关对象相互同步，方法是让另一个对象负责，在这组对象中的任何一个发生改变时，由它把这种变化通知给这个组里的所有对象|
|Singleton（单例）|为有且仅有一个实例的类提供一种全局访问功能|
|Strategy（策略）|定义一组算法或者行为，使得它们可以动态地相互替换|
|Template Method（模板方法）|定义一个操作的算法结构，但是把部分实现的细节留给子类（派生类）|

应用模式存在的两个陷阱：
- 强迫让代码适用于某个模式。
- “为了模式而模式”。

推荐资源：https://refactoringguru.cn/design-patterns/catalog

#### 3.1.9 其他的启发式方法
不太常用，但值得一试的一些启发式方法：
- 高内聚性
  - 内聚性指的是类内部的子程序或者子程序内的所有代码都支持一个中心目标上的紧密程度（类的目标是否集中）。

- 构造分层结构
  - 在软件中分层结构中，最通用的或者最抽象的概念表示位于层次关系的最上面，而更加详细的具有特定意义的概念则放在更低的层次中。

- 严格描述类契约
  - 把类的结偶看作是程序的其余部分之间的一项契约并有助于更好地洞察程序。

- 分配职责
  - 为对象分配职责。

- 为测试而设计

- 避免失误

- 有意识地选择绑定时间
  - 指的是把特定的值绑定到某一个变量的时间。

- 创建中央控制点
  - 唯一一个正确位置的准则（对于每一段有作用的代码，都应该只有唯一的地方可见，并只能在一个正确的位置去做可能的维护性修改）。

- 考虑使用蛮力突破
- 画一个图
- 保持设计的模块化
  - 模块化的目标：使每个子程序或者类看似黑盒。
  - 黑盒的接口设计和定义明确的功能，对于给定任何特定的输入，都可以准确预期对应的输出结果。

### 3.2 使用启发式方法的原则
G.Polya 在数学领域发展的一套解决问题的方法，它同样适用于解决软件设计中的问题。

- 必须理解问题
- 设计一个计划，找出现有的数据和未知量之间的联系。
- 执行计划。
- 回顾，并检视整个的解。

最有效的原则之一：不要卡在单一的方法上，也无须马上解决整个设计难题。

## 4. 设计实践

- 迭代
- 分而治之
  - 参考Polya在数学问题中所建议的方法来进行增量式地改进。

- 自上而下和自下而上的设计方法
  - 自上而下：从某个高的抽象层次开始（分解策略）。
  - 自下而上：始于细节，并向一般性延伸（合成策略）。

- 建立试验性原型
  - 写出用于回答特定设计问题的、量最少且能够随时扔掉代码的活动。
- 合作设计
- 记录你的设计成果


# Chapter 06 可以工作的类
成为高效程序员的一个关键：开发程序任一部分代码时，都能安全地忽略程序中尽可能多的其余部分。

## 1. 类的基础：抽象数据类型
**`抽象数据类型（Abstract Data Types（ADTs））`**：指一些数据以及对这些数据进行操作的集合。

### 1.1 使用ADT的好处
- 可以隐藏实现细节
- 改动不影响到整个程序
- 让接口能提供更多信息
- 更容易提高性能
- 让程序的正确性更显而易见
- 程序更具有自我说明性
- 无须在程序内部到处传递数据
- 可以像在现实世界中那样操作实体，而不用在底层实现上操作它。

## 2. 良好的类接口
创建高质量类的第一步，也可能是最重要的一步：创建一个好的接口。

- 抽象通过提供一个可以让你忽略实现细节的模型来管理复杂度。
- 封装则强制阻止看到细节。

### 2.1 好的抽象
- 对类的抽象进行评估的方法：基于类所具有的公用（public）子程序所构成的集合（类的接口）。

- 一些创建类的抽象接口的指导建议：
  - 类的接口应该展现一致的抽象层次
    - 把类当作一种用来实现抽象数据类型的机制。
    - 每一个类应该实现一个ADT，并且仅实现这个ADT。

  - 一定要理解类所实现的抽象是什么
  - 提供成对的服务
    - 大多数都有和它其相对应的、相等的以及相反的操作。
    - 不要盲目创建相反的操作，而是应该考虑是否需要。

  - 把不相关的信息转移到其他类中
  - 尽可能让接口可编程，而不是表达语义
    - 每个接口都由一个可编程的部分和一个语义部分组成。
      - 可编程部分：由接口中的数据类型和其他属性构成。
        - 编译器会强制要求（在编译时检查错误）。
      - 语义部分：由“本接口将会怎样被使用”的假定组成（依赖关系，使用A之前需要调用B）。
        - 编译器无法强制检查。

  - 谨防在修改时破坏接口的抽象
  - 不要添加与接口愁绪不一致的公用成员
    - 每次向类的接口中添加子程序时，尽量去保证抽象的完整性。

  - 同时考虑抽象性和内聚性
    - 一个好的抽象的类接口同时也有很高的内聚性。
  
关注类的接口所表现出来的抽象，比关注类的内聚性更有助于深入理解类的设计。

### 2.2 好的封装
- “设计精良的模块和设计糟糕的模块的唯一最大区别，就是对其他模块隐藏本模块内部数据和其他实现细节的程度。” ——Joshua Bloch。

- 关于类的封装接口的一些指导建议：
  - 尽可能地限制类和成员的可访问性
    - 采用最严格且可行的访问级别设置（public、private、protected）。
    - 如果不确定，多隐藏也比少隐藏好。

  - 不要公开暴露成员数据
    - 暴露成员数据会破坏封装性，从而限制对抽象的控制能力。

  - 避免把私用的实现细节放入类的接口中
  - 不要对类的使用者做出任何假设
  - 避免使用友元类
  - 不要因为一个子程序里仅使用公用子程序，就把它归入公开接口。
  - 让阅读代码比编写代码更加方便
  - 要格外警惕从语义上破坏封装性
    - 让调用方代码不是依赖类的公开接口，而是依赖类的私用实现。
  - 留意过于紧密的耦合关系
    - 两个类之间关联的紧密程度。
    - 关联越松越好。
    - 关于耦合的指导建议：
      - 尽可能限制类和成员的可访问性。
      - 避免友元类，因为是紧密耦合。
      - 在基类中把数据声明为private而不是prtected，以降低派生类和基类之间耦合的程度。
      - 避免在类的公开接口中暴露成员数据。
      - 要对语义上破坏封装性保持警惕。
      - 察觉“Demeter（得墨特耳）”法则。

## 3. 有关设计和实现的问题
给类定义合理的借口，对于创建高质量程序起到了关键作用。

### 3.1 包含（“有一个...”的关系）
包含表示一个类含有一个基本数据元素或对象。相比继承，包含是面向对象编程中的主力技术。

- 通过包含来实现 “有一个/has a” 的关系
- 在万不得已时通过private继承来实现 “有一个” 的关系
- 警惕有超过约7个数据成员的类


### 3.2 继承（“是一个...”的关系）
继承：一个类是另一个类的一种特化（specialization）。

继承的目的：通过“定义能为两个或者更多派生类提供共有元素的基类”的方式写出更精简的代码。

继承的好处：有助于避免在多处出现重复的代码和数据。

当使用继承时，需要考虑的注意事项：
- 用public 继承来实现 “是一个...” 的关系
- 要么使用继承并进行详细说明，要么不使用
- 遵循Liskov替换原则（Liskov Substitution Principle, LSP）
- 确保只继承需要继承的部分
- 不要 “覆盖” 一个不可覆盖的成员函数。
- 把共有的接口、数据及操作放到继承树中尽可能高的位置
- 只有一个实例的类是值得怀疑的。
- 只有一个派生类的基类也值得怀疑。
- 派生后覆盖了某个子程序，但在其中没做任何操作，这种情况也值得怀疑。
- 避免让继承体系过深
- 尽量使用多态、避免大量的类型检查。
- 让所有数据都是private（而非protected）。

### 3.3 使用继承还是包含的规则总结
- 如果多个类共享数据而非行为，则创建这些类可以包含的共用对象。
- 如果多个类共享数据而非行为，则让它们从共同的基类继承而来，并在基类里定义共用的子程序。
- 如果多个类既共享数据也共享行为，则从一个共同的基类继承而来，并在基类里定义共用的数据和子程序。
- 想由基类控制接口时，使用继承，想自己控制接口，则使用包含。

### 3.4 成员函数和数据成员
对于实现成员函数和数据成员的一些指导建议：
- 让类中子程序的数量尽可能少
- 禁止隐式地产生你不需要的成员函数和运算符
- 减少类所调用的不同子程序的数量
- 对其他类的子程序的间接调用要尽可能少
- 一般来说，应尽量减小类和类之间相互合作的范围
  - 尽量减少以下的数字到最小：
    - 所实例化的对象的种类
    - 在被实例化对象上直接调用的不同子程序的数量
    - 调用其他对象返回的对象的子程序的数量。

### 3.5 构造函数
对于构造函数的指导建议：
- 如果可能，应该在所有的构造函数中初始化所有的数据成员。
  - 做到防御式编程。
- 用私用构造函数来强调实现单例属性

- 优先采用深层拷贝，除非论证可行，才采用浅层拷贝。
  - 深拷贝：对象成员数据逐项复制的结果。
  - 浅拷贝：只是指向或引用同一个实际对象。

## 4. 创建类的原因
- 为现实世界中男的对象建模
- 为抽象的对象建模
- 降低复杂度
- 隔离复杂度
- 隐藏实现细节
- 限制变动的影响范围
- 隐藏全局数据
- 让参数传递更顺畅
- 建立中心控制点
- 让代码更易于重用
- 为程序族做计划
- 把相关操作包装到一起
- 实现某种特定重构

## 6. 应该避免的类
- 避免创建万能类
- 消除无关紧要的类
- 避免用动词命名的类

## 7. 与具体编程语言相关的问题
不同语言之间和类相关的存在差异的地方：
- 在继承层次中被覆盖的构造函数和析构函数的行为。
- 在异常处理时构造函数和析构函数的行为。
- 默认构造函数（即无参数的构造函数）的重要性。
- 析构函数或者终结器（finalizer）的调用时机。
- 和覆盖语言内置的运算符（包括赋值和等号）相关的知识。
- 当对象被创建和销毁时，或当其被声明时，或者它所在的作用域退出时，处理内存的方式。


## 8. 超越类：包
类是当前程序员们实现模块化的最佳方式。

为了更好地使用封装和抽象，一些编程语言也引入了包的概念，对于包的则遵循对应的编程标准：
- 用于区分 “公用的类” 和 “某个包私用的类” 的命名规则。
- 为了区分每个类所属的包而制定的命名规则或代码组织规则（即项目结构）。
- 规定什么包可以用其他什么包的规则，包括是否可以用继承和包含等。

# Chapter 07 高质量的子程序
**`子程序`** 是为实现一个特定的目的而编写的一个可被调用的方法或者过程。

## 1. 创建子程序的正当理由
- 降低复杂度
  - 当内部循环和条件判断的嵌套层次很深时，则需要从子程序中提取出新的子程序，从而降低外围子程序的复杂度。

- 引入中间、易懂的抽象
  - 将代码重新组织，并引入一个新的抽象名，使代码更易于理解。

- 避免代码重复
  - 将共同的放入基类，将差异部分放入派生类中。
  - 减少重复代码出现的次数，可以节约空间，并且改动或者验证方便。

- 支持子类化
- 隐藏顺序
- 隐藏指针操作
  - 指针可读性差，容易出错。
- 提高可移植性
- 简化复杂的布尔判断
- 改善性能
  - 把代码集中一处，后续使用更高效的算法或者语言来重写时很容易。

- 确保所有的子程序都很小

此外，创建类的很多理由也是创建子程序的理由。
- 隔离复杂性
- 隐藏实现细节
- 限制变化带来的影响
- 隐藏全局数据
- 形成中央控制点
- 促成可重用的代码
- 达到特定的重构目的

编写有效的子程序时，一个最大的心理障碍是不情愿为一个简单的目的而编写一个简单子程序。小的子程序能提高可读性，并容易扩展。
## 2. 在子程序上设计
- 在类的设计上，抽象和封装在类层次上已经很大程度上取代了内聚性。但在单个子程序层次上，仍然是设计时常用的启发式方法。

- 对子程序来说，内聚性是指子程序中各种操作之间联系的紧密程度。目标是让每个子程序只把一件事情做好，不做任何其他的事情。

关于内聚性的可采用的几个层次讨论：
- 功能的内聚性
  - 最强也是最好的一种内聚性。即让一个子程序仅执行一项操作。
- 顺序上的内聚性
  - 指在子程序内包含有需要按特定顺序执行的操作，这些步骤需要共享数据，并在全部执行完毕后才可以完成整个功能。
- 通信上的内聚性
  - 指一个子程序中的不同操作使用了同样的数据，但不去存在其他任何联系。
  - 优化方式：将子程序拆分分解成多个子程序。

- 临时的内聚性
  - 指含有一些需要同时执行才放到一起操作的子程序。
  - 优化方式：
    - 把临时性的子程序看作是一系列事件的组织者。要想让它生效，则使用原临时性内聚的子程序去调用其他的子程序。即让子程序来完成特定的操作，而不是由它直接执行所有的操作。

除了功能的内聚性外，其它类型的内聚性不可取，尽量想办法避免，不可采用的几个内聚性：
原因：会导致代码组织混乱、难于调试、不便修改。
- 过程上的内聚性
  - 指一个子程序中的操作是按特定的顺序进行的。
- 逻辑上的内聚性
  - 若干个操作被放入到同一个子程序中，通过传入的控制标志选择执行其中一项操作。

- 巧合的内聚性
  - 子程序中的各个操作之间没有任何可以看到的关联。有时也叫做“无内聚性” 或者 “混乱的内聚性”。

## 3. 好的子程序名字
好的子程序名字能清晰地描述子程序所做的一切。

- 描述子程序所做的所有事情
  - 子程序的名字应当描述其所有的输出结果以及副作用。

- 避免使用无意义的、模糊或表述不清的动词

- 不要仅仅通过数字来形成不同的子程序
- 根据需要确定子程序名字的长度
- 给函数命名时要对返回值有所描述
- 给过程起名时要使用语气强烈的动词加宾语的形式
- 准确使用对仗词
- 为常用操作确立命名规则

## 4. 子程序可以写多长？


## 5. 如何使用子程序参数？


## 6. 使用函数时要特别考虑的问题



## 7. 宏子程序和内联子程序






# Chapter 08 防范式编程


## 1. 保护程序免遭无效输入数据的破坏


## 2. 断言


## 3. 错误处理技术


## 4. 异常


## 5. 隔离程序以免遭由错误造成的损害


## 6. 辅助调试代码



## 7. 确定在产品代码中该保留多少防范式代码


## 8. 防范式编程时保持防范





# Chapter 09 伪代码编程过程


## 1. 创建类和子程序的步骤概述


## 2. 伪代码


## 3. 通过伪代码编程过程创建子程序


## 4. 伪代码编程过程之外的其它方案


